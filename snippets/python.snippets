snippet ifm "if main" b
if __name__ == "__main__":
	main($0)
endsnippet

snippet ifmd "if main with ipdb on exception" b
if __name__ == "__main__":
	with __import__("ipdb").launch_ipdb_on_exception():
		main($0)
endsnippet

snippet dbg "launch ipdb on exception"
with __import__("ipdb").launch_ipdb_on_exception():
	${VISUAL}
endsnippet

snippet gul "update globals with locals"
globals().update(locals())
endsnippet

snippet fifo "fifo + subprocess"
import os
import tempfile
import subprocess as sp

# mktemp is currently considered unsafe as it returns a child of /tmp on
# Unix, so the path might be hijacked by an attacker (/tmp is world
# writable and the name is too short to be unguessable in practice).
# Though if hijacked by a malicious file, mkfifo will fail, so the worst
# that can happen is a crash (because we don't handle the failure, e.g.
# retry with a different name). A partial mitigation is to first create
# a private temp dir, reducing the risk of collision to processes run by
# the same/super user.
fifo_path = tempfile.mktemp()
os.mkfifo(fifo_path, 0o600)
try:
	# Opening a FIFO for writing blocks until someone else opens it for
	# reading, so we can't open for writing first or we'd block forever.
	# Instead, we first launch the subprocess which will read from the
	# FIFO. We have to do it in a non-blocking manner though, so that we
	# can go on to actually write to the FIFO, so no sp.run.
	proc = sp.Popen(["cat", fifo_path], stdout=sp.PIPE, text=True)
	with open(fifo_path, "w") as fifo:
		for c in "Kočka leze dírou, pes oknem.":
			print(c, file=fifo)
	proc.wait()
finally:
	os.unlink(fifo_path)

for l in proc.stdout:
	print(l.strip())
endsnippet

snippet richlog "logging with rich"
import logging
from rich.console import Console
from rich.logging import RichHandler

logging.basicConfig(
	level=logging.NOTSET,
	format="%(message)s",
	handlers=[
		RichHandler(console=Console(stderr=True), rich_tracebacks=True, markup=True)
	],
)

log = logging.getLogger("rich")
log.info("Starting up...")
try:
	print(1 / 0)
except Exception:
	log.exception("Unable to print!")
log.error("[bold red blink]Server is shutting down![/]")

# markup=True can be problematic according to the docs, so it can also
# be enabled per-message (which doesn't make it not problematic, it just
# limits the potential problems to that message):
# log.error("[bold red blink]Server is shutting down![/]", extra={"markup": True})
endsnippet

snippet richbar "monitoring progress with rich"
import time
from rich.console import Console
from rich.progress import track

console = Console()
console.log("[bold yellow]Started.[/]")
for _ in track(list(range(5)), description="Running..."):
	time.sleep(1)
console.log("[bold green blink]Done.[/]")
endsnippet

snippet logbc "logging basic config"
import logging
from pathlib import Path

LOG_PATH = Path(__file__).with_suffix(".log")

logging.basicConfig(
	filename=LOG_PATH,
	level=logging.INFO,
	format="%(asctime)s\t%(levelname)s\t%(name)s\t%(message)s",
	datefmt="%Y-%m-%d %H:%M:%S",
)
endsnippet

# vi: noet ts=4
