# ----------------------------------------------------------------------- Script headers {{{1

snippet sh
#!/bin/sh

${1:# exit on error; no unset variables; no pathname expansion; trace execution}
set -eufx
script_dir=$(dirname "$(realpath "\$0")")
script_name=$(basename "\$0")
$0
endsnippet

snippet bash
#!/bin/sh

${1:# exit on error; no unset variables; no pathname expansion; trace execution; no silent errors in the middle of a pipeline}
set -eufxo pipefail
script_dir=$(dirname "$(realpath "\$0")")
script_name=$(basename "\$0")
$0
endsnippet


# ------------------------------------------------- Argument parsing & usage information {{{1

snippet help
help() {
	printf "\
Usage: $script_name ${1:positional args}

${2:What this script does, in one line.}

Options:
"
	awk '/--)/{flag=0} flag; /case "\\\$1" in/{flag=1}' "$script_dir/$script_name" |
		sed 's/^ \+//; s/|/, /; s/)//; s/# //' |
		grep '^-'
${3:
	printf "
Possibly more details on what this script does.
"}
}
$0
endsnippet

snippet getopt
set +e
tmp=$(
	${1:# '-o +...' allows arbitrary options trailing after the first non-option argument,
	# which is handy for passing them on to a subprogram; append :/:: to both a short and
	# its corresponding long option to make it take a mandatory/optional argument}
	getopt -n "$script_name" \
		-o ${2:+hab} \
		-l ${3:help,long-a,long-b} \
		-- "$@"
)
if [ $? -ne 0 ]; then
	help >&2; exit 1
fi
set -e
${4:# 'set --' sets $@; eval peels off one layer of quotes (generated by getopt to preserve
# whitespace)}
eval set -- "$tmp"
unset tmp
$0
endsnippet

snippet opts
while [ -n "\${1-}" ]; do
	case "\$1" in
		-h|--help)           # show help
			help; exit;;
		${1:-a|--long-a})         ${3:# toggle option A}
			${2:long_a}=1; shift;;
		${4:-b|--long-b})         ${6:# toggle option B}
			${5:long_b}=1; shift;;
		--)
			${7:# The remainder of $@ is positional arguments and/or unparsed options, if any.}
			shift; break;;
		${8:# Only needed when not using getopt to parse the options.
		*)
			>&2 echo "$script_name: unrecognized option '\$1'"
			abort=1; shift;;}
	esac
done
${9:# Only needed when not using getopt to parse the options.
if [ -n "$\{abort-\}" ]; then
	help >&2; exit 1
fi
}
$0
endsnippet


# ----------------------------------------------------------------------- User interface {{{1

snippet yesno "ask for confirmation"
while true; do
		>&2 read -p '${1:question} [yes/no]: ' yn
		case "$yn" in
				[Yy]*) break;;
				[Nn]*) exit 1;;
				*) >&2 echo 'Please answer yes or no.';;
		esac
done
endsnippet

snippet sep "print separator line"
{ printf "${0:=}%.s" $(seq $(tput cols)); echo; } >&2
endsnippet


# --------------------------------------------------------- Command invocation reminders {{{1

snippet echo
${1:>&2 }printf "\
$0
"
endsnippet

# NOTE: Terminating child processes on exit is unfortunately extremely finicky,
# especially if you want to make it work across various shells. Piping 'jobs -p | ...'
# doesn't work in dash, because pipeline commands run in a subshell, so there are no
# jobs to report. The workaround would be to save the output of 'jobs' to a file. See
# details here: <https://bugs.launchpad.net/ubuntu/+source/dash/+bug/243406>.
#
# Also, if any of the jobs started any additional processes, it's up to the jobs to
# clean up after themselves, 'jobs -p | xargs kill' only kills the immediate children.
# Alternatives like 'kill 0' or 'kill -- -$$' do get them because they kill the entire
# process group (assuming the children haven't switched process groups, which they can),
# but they also kill the parent right then and there, which means you lose the exit
# status...
#
# ... unless you're using dash, which seems to preserve the exit status automatically,
# so you could trap just 'kill 0', without needing to manually preserve 'status=$?'.
# However, only rely on this when explicitly invoking the script with dash -- remember
# that /bin/sh can also be bash.
#
# In any case, when using one of the two kill-based alternatives, you either need two
# separate traps, converting INT, TERM, QUIT and HUP to EXIT and only running cleanup on
# EXIT, or unregister the TERM trap in cleanup with 'trap - TERM', to avoid infinite
# recursion.
#
# And because there's apparently no end to excruciating caveats: 'kill -- -$$' will only
# work for scripts directly launched from an interactive shell, which become their own
# process group leaders. But if you call the script from another script, it will be part
# of the latter script's process group, so there will be no process group with its PID
# (i.e. no '-$$'). See <https://stackoverflow.com/a/52126776>. Sigh.
#
# And just because fuck you for trying to make this work on zsh too, even if you
# probably don't really need it, 'status' is a specially read-only variable in zsh, so
# you have to use 'code' instead. And just because fuck you twice, zsh also doesn't have
# a proper 'jobs -p', so you need 'jobs -l' + sed.
#
# 'if ps then kill' is technically a race condition, but while it can't completely avoid
# issuing kill to a process that's gone, at least it makes it less likely and the output
# therefore less noisy. We ignore the error anyway with '|| true', but we want to see
# stderr in case some unexpected error happens, so '2>/dev/null' instead of 'if ps' is
# not an option.
#
# For more discussion on this entire topic, see <https://stackoverflow.com/q/360201>.
snippet trap "kill children on exit while preserving exit code"
cleanup() {
	# NOTE: This only kills direct children still under job control. If you want to kill
	# the entire process group (except for children who might have changed their process
	# group), use 'trap - TERM; kill 0', at the expense of losing the exit status, unless
	# using dash.
	local code=$?
	jobs=$(mktemp)
	jobs -l >"$jobs"
	for pid in $(sed 's/.*\? \([[:digit:]]\+\) .*/\1/' <"$jobs"); do
		if ps $pid >/dev/null; then
			kill -- $pid || true
		fi
	done
	return $code
}
trap cleanup INT TERM QUIT HUP EXIT
endsnippet

snippet wait "wait without breaking set -e"
# NOTE: Always wait on each PID *explicitly and separately*. A bare 'wait' ignores the
# background processes' status codes and always returns 0; 'wait pid1 pid2' ignores
# job1's status code and always returns job2's.
wait ${1:pid}
endsnippet

snippet grep "grep: just filter, don't test"
# A grep that doesn't exit 1 when no match is found.
grep0() {
	# NOTE: In Bash <4 (which is what macOS is stuck with for GPL reasons), 'command' is
	# buggy w.r.t. 'set -e'. Workarounds: remove 'command', or wrap it in a subshell. See
	# <https://stackoverflow.com/a/68144864> for details.
	if ! command grep "$@"; then
		local status=$?
		if [ $status -eq 1 ]; then
			return 0
		else
			return $status
		fi
	fi
}
endsnippet

snippet curl
${1:# -sSf: silent, show error on failure, but no output (e.g. 404 page)
# -L: follow redirects;
# -O: determine output filename from URL}
curl -sSfLO $0
${2:# -o <filename>: specify output filename
# -k: ignore expired SSL certificates}
endsnippet

snippet awk "filter ranges of lines with awk"
${1:# This deletes the range of lines between start pattern and end pattern, excluding
# end pattern. Shuffle the pieces around to get outer/inner inclusive/exclusive ranges.
# For printing an inner inclusive range, use /start pattern/,/end pattern/ or /start
# pattern/,/END/ to print to the end of the file.
}awk '/${2:start pattern}/{d=1} /${3:end pattern}/{d=0} !d'
endsnippet

# vi: noet ts=2 foldmethod=marker
