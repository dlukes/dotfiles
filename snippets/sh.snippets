# ----------------------------------------------------------------------- Script headers {{{1

snippet sh
#!/bin/sh

${1:# exit on error; no unset variables; no pathname expansion; trace execution}
set -eufx
script_dir=$(dirname "$(realpath "\$0")")
script_name=$(basename "\$0")
$0
endsnippet

snippet bash
#!/bin/sh

${1:# exit on error; no unset variables; no pathname expansion; trace execution; no silent errors in the middle of a pipeline}
set -eufxo pipefail
script_dir=$(dirname "$(realpath "\$0")")
script_name=$(basename "\$0")
$0
endsnippet


# ------------------------------------------------- Argument parsing & usage information {{{1

snippet help
help() {
	printf "\
Usage: $script_name ${1:positional args}

${2:What this script does, in one line.}

Options:
"
	awk '/--)/{flag=0} flag; /case "\\\$1" in/{flag=1}' "$script_dir/$script_name" |
		sed 's/^ \+//; s/|/, /; s/)//; s/# //' |
		grep '^-'
${3:
	printf "
Possibly more details on what this script does.
"}
}
$0
endsnippet

snippet getopt
set +e
tmp=$(
	${1:# '-o +...' allows arbitrary options trailing after the first non-option argument,
	# which is handy for passing them on to a subprogram; append :/:: to both a short and
	# its corresponding long option to make it take a mandatory/optional argument}
	getopt -n "$script_name" \
		-o ${2:+hab} \
		-l ${3:help,long-a,long-b} \
		-- "$@"
)
if [ $? -ne 0 ]; then
	help >&2; exit 1
fi
set -e
${4:# 'set --' sets $@; eval peels off one layer of quotes (generated by getopt to preserve
# whitespace)}
eval set -- "$tmp"
unset tmp
$0
endsnippet

snippet opts
while [ -n "\${1-}" ]; do
	case "\$1" in
		-h|--help)           # show help
			help; exit;;
		${1:-a|--long-a})         ${3:# toggle option A}
			${2:long_a}=1; shift;;
		${4:-b|--long-b})         ${6:# toggle option B}
			${5:long_b}=1; shift;;
		--)
			${7:# The remainder of $@ is positional arguments and/or unparsed options, if any.}
			shift; break;;
		${8:# Only needed when not using getopt to parse the options.
		*)
			>&2 echo "$script_name: unrecognized option '\$1'"
			abort=1; shift;;}
	esac
done
${9:# Only needed when not using getopt to parse the options.
if [ -n "$\{abort-\}" ]; then
	help >&2; exit 1
fi
}
$0
endsnippet


# ----------------------------------------------------------------------- User interface {{{1

snippet yesno "ask for confirmation"
while true; do
		>&2 read -p '${1:question} [yes/no]: ' yn
		case "$yn" in
				[Yy]*) break;;
				[Nn]*) exit 1;;
				*) >&2 echo 'Please answer yes or no.';;
		esac
done
endsnippet

snippet sep "print separator line"
{ printf "${0:=}%.s" $(seq $(tput cols)); echo; } >&2
endsnippet


# --------------------------------------------------------- Command invocation reminders {{{1

snippet echo
${1:>&2 }printf "\
$0
"
endsnippet

snippet trap "kill children on exit"
trap exit INT TERM HUP
trap 'kill 0' EXIT
endsnippet

snippet curl
${1:# -sSf: silent, show error on failure, but no output (e.g. 404 page)
# -L: follow redirects;
# -O: determine output filename from URL}
curl -sSfLO $0
${2:# -o <filename>: specify output filename
# -k: ignore expired SSL certificates}
endsnippet

# vi: noet ts=2 foldmethod=marker
