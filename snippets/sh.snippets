# ----------------------------------------------------------------------- Script headers {{{1

snippet sh
#!/bin/sh

${1:# exit on error; no unset variables; no pathname expansion; trace execution}
set -eufx
script_dir=$(dirname "$(realpath "\$0")")
script_name=$(basename "\$0")
$0
endsnippet

snippet bash
#!/bin/sh

${1:# exit on error; no unset variables; no pathname expansion; trace execution; no silent errors in the middle of a pipeline}
set -eufxo pipefail
script_dir=$(dirname "$(realpath "\$0")")
script_name=$(basename "\$0")
$0
endsnippet


# ------------------------------------------------- Argument parsing & usage information {{{1

snippet help
help() {
	printf "\
Usage: $script_name ${1:positional args}

${2:What this script does, in one line.}

Options:
"
	awk '/--)/{flag=0} flag; /case "\\\$1" in/{flag=1}' "$script_dir/$script_name" |
		sed 's/^ \+//; s/|/, /; s/)//; s/# //' |
		grep '^-'
${3:
	printf "
Possibly more details on what this script does.
"}
}
$0
endsnippet

snippet getopt
set +e
tmp=$(
	${1:# '-o +...' allows arbitrary options trailing after the first non-option argument,
	# which is handy for passing them on to a subprogram; append :/:: to both a short and
	# its corresponding long option to make it take a mandatory/optional argument}
	getopt -n "$script_name" \
		-o ${2:+hab} \
		-l ${3:help,long-a,long-b} \
		-- "$@"
)
if [ $? -ne 0 ]; then
	help >&2; exit 1
fi
set -e
${4:# 'set --' sets $@; eval peels off one layer of quotes (generated by getopt to preserve
# whitespace)}
eval set -- "$tmp"
unset tmp
$0
endsnippet

snippet opts
while [ -n "\${1-}" ]; do
	case "\$1" in
		-h|--help)           # show help
			help; exit;;
		${1:-a|--long-a})         ${3:# toggle option A}
			${2:long_a}=1; shift;;
		${4:-b|--long-b})         ${6:# toggle option B}
			${5:long_b}=1; shift;;
		--)
			${7:# The remainder of $@ is positional arguments and/or unparsed options, if any.}
			shift; break;;
		${8:# Only needed when not using getopt to parse the options.
		*)
			>&2 echo "$script_name: unrecognized option '\$1'"
			abort=1; shift;;}
	esac
done
${9:# Only needed when not using getopt to parse the options.
if [ -n "$\{abort-\}" ]; then
	help >&2; exit 1
fi
}
$0
endsnippet


# ------------------------------------------------------------------ Cleaning up on exit {{{1

# 'if ps then kill' is technically a race condition, but while it can't completely avoid
# issuing kill to a process that's gone, at least it makes it less likely and the output
# therefore less noisy. We ignore the error anyway with '|| true', but we want to see
# stderr in case some unexpected error happens, so '2>/dev/null' instead of 'if ps' is
# not an option.
snippet trapfancy "kill children on exit (portable)"
cleanup() {
	# NOTE: This only kills direct children still under job control. If you want to kill
	# the entire process group (except for yourself, so as to finish the cleanup), then
	# see the commented out alternatives to 'jobs -l' + sed below.
	local code=$?
	local sig=\$1
	jobs=$(mktemp)
	jobs -l >"$jobs"
	for pid in $(sed 's/.*\? \([[:digit:]]\+\) .*/\1/' <"$jobs"); do
	# for pid in $(ps -g $$ -o pid=); do
		if ps $pid >/dev/null; then
		# if ps $pid >/dev/null && [ $pid -ne $$ ]; then
			kill -- $pid || true
			# You might want to propagate the specific $sig to the children in some cases
			# instead of just always sending them SIGTERM.
			# kill -$sig -- $pid || true
		fi
	done
	if [ $sig = EXIT ]; then
		trap - EXIT
		exit $code
	else
		trap - $sig EXIT
		kill -$sig $$
	fi
}
for sig in HUP INT QUIT PIPE TERM EXIT; do
	trap "cleanup $sig" $sig
done
endsnippet

snippet trapbash "kill children on exit (Bash)"
# This is Bash-only but optimal: short, simple, propagates signals correctly, doesn't
# have to wait for current foreground command to complete before running trap when
# signal arrives (because no signals are trapped, just EXIT, which also runs on signals
# in Bash).
trap 'kill 0' EXIT
endsnippet

snippet trapdash "kill children on exit (Dash)"
# This is a poor man's Dash-only alternative to the elegant Bash solution. Signals are
# converted to regular exits with code 128 + signal number (not in Bash, where the exit
# is 0, so DO NOT USE IN BASH!). And since you're trapping signals, you can only get
# interrupted in between foreground commands.
trap exit HUP INT QUIT PIPE TERM
trap 'kill 0' EXIT
endsnippet


# ----------------------------------------------------------------------- User interface {{{1

snippet yesno "ask for confirmation"
while true; do
		>&2 read -p '${1:question} [yes/no]: ' yn
		case "$yn" in
				[Yy]*) break;;
				[Nn]*) exit 1;;
				*) >&2 echo 'Please answer yes or no.';;
		esac
done
endsnippet

snippet sep "print separator line"
{ printf "${0:=}%.s" $(seq $(tput cols)); echo; } >&2
endsnippet


# --------------------------------------------------------- Command invocation reminders {{{1

snippet echo
${1:>&2 }printf "\
$0
"
endsnippet

snippet wait "wait without breaking set -e"
# NOTE: Always wait on each PID *explicitly and separately*. A bare 'wait' ignores the
# background processes' status codes and always returns 0; 'wait pid1 pid2' ignores
# job1's status code and always returns job2's.
wait ${1:pid}
endsnippet

snippet grep "grep: just filter, don't test"
# A grep that doesn't exit 1 when no match is found.
grep0() {
	# NOTE: In Bash <4 (which is what macOS is stuck with for GPL reasons), 'command' is
	# buggy w.r.t. 'set -e'. Workarounds: remove 'command', or wrap it in a subshell. See
	# <https://stackoverflow.com/a/68144864> for details.
	if ! command grep "$@"; then
		local status=$?
		if [ $status -eq 1 ]; then
			return 0
		else
			return $status
		fi
	fi
}
endsnippet

snippet curl
${1:# -sSf: silent, show error on failure (incl. failed writing body when piping), but no output (e.g. 404 page)
# -L: follow redirects;
# -OJ: determine output filename from URL or header (if available)}
curl -sSfLOJ $0
${2:# -o <filename>: specify output filename
# -k: ignore expired SSL certificates}
endsnippet

snippet awk "filter ranges of lines with awk"
${1:# This deletes the range of lines between start pattern and end pattern, excluding
# end pattern. Shuffle the pieces around to get outer/inner inclusive/exclusive ranges.
# For printing an inner inclusive range, use /start pattern/,/end pattern/ or /start
# pattern/,/END/ to print to the end of the file.
}awk '/${2:start pattern}/{d=1} /${3:end pattern}/{d=0} !d'
endsnippet

# vi: noet ts=2 foldmethod=marker
